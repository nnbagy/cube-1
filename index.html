<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Particles â€“ Mobile Optimized</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: #000;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      width: 100vw;
      height: 100vh;
      position: fixed;
    }
    canvas { 
      display: block; 
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>

let scene, camera, renderer, sphere, uniforms;
let mouse = new THREE.Vector3();
let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
let particleCount, pointSize, spreadMultiplier;

init();
animate();

function init() {
    scene = new THREE.Scene();

    // Adjust for mobile aspect ratio
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 1000);
    camera.position.z = isMobile ? 3.0 : 3; // Closer for wider view

    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
    });
    
    // Set proper size for device
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
    document.body.appendChild(renderer.domElement);

    // Adjust particle count and size for mobile
    particleCount = isMobile ? 15000 : 50000;
    pointSize = isMobile ? 2.0 : 1.0;
    
    // WIDER SPREAD - increased from 2 to 3 for left-right spread
    spreadMultiplier = isMobile ? 3.0 : 2.5; // Mobile gets even wider spread

    const positions = new Float32Array(particleCount * 3);

    // Create particles in a WIDER cube shape
    for (let i = 0; i < particleCount; i++) {
        // WIDER horizontal spread (X-axis), normal vertical (Y), normal depth (Z)
        positions[i*3] = (Math.random() - 0.5) * spreadMultiplier;     // X: wider
        positions[i*3+1] = (Math.random() - 0.5) * (spreadMultiplier * 0.7);  // Y: slightly less wide
        positions[i*3+2] = (Math.random() - 0.5) * (spreadMultiplier * 0.8);  // Z: slightly less wide
    }

    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    uniforms = {
        uTime: { value: 0.0 },
        uMouse: { value: new THREE.Vector3(0,0,0) },
        uPointSize: { value: pointSize }
    };

    const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
            uniform vec3 uMouse;
            uniform float uPointSize;
            
            void main() {
                vec3 pos = position;

                float dist = distance(pos, uMouse);
                if (dist > 0.01) { // Avoid division by zero
                    // Reduced interaction strength for wider spread
                    pos += normalize(pos - uMouse) * (0.12 / dist);
                }

                gl_PointSize = uPointSize;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            void main() {
                // Circular particles with smooth edges
                float d = distance(gl_PointCoord, vec2(0.5));
                if (d > 0.5) discard;
                
                // Smooth alpha for better looking particles
                float alpha = 1.0 - smoothstep(0.3, 0.5, d);
                gl_FragColor = vec4(0.2, 0.6, 1.0, alpha);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    sphere = new THREE.Points(particleGeometry, material);
    scene.add(sphere);

    // Handle both mouse and touch events
    function updatePointerPosition(x, y) {
        // Convert to normalized device coordinates (-1 to +1)
        const normalizedX = (x / window.innerWidth) * 2 - 1;
        const normalizedY = -(y / window.innerHeight) * 2 + 1;
        
        // Adjust for wider spread - mouse position matches particle spread
        mouse.set(normalizedX * (spreadMultiplier/2), normalizedY * (spreadMultiplier/2 * 0.7), 0.3);
        uniforms.uMouse.value.copy(mouse);
    }

    // Mouse events
    window.addEventListener("mousemove", (e) => {
        updatePointerPosition(e.clientX, e.clientY);
    });

    // Touch events for mobile
    window.addEventListener("touchstart", (e) => {
        e.preventDefault();
        if (e.touches.length > 0) {
            updatePointerPosition(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    window.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (e.touches.length > 0) {
            updatePointerPosition(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });

    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', onWindowResize);
}

function onWindowResize() {
    // Update camera aspect ratio
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    
    // Update renderer size
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
}

function animate() {
    requestAnimationFrame(animate);
    
    uniforms.uTime.value += 0.01;
    sphere.rotation.y += 0.002;
    
    renderer.render(scene, camera);
}

</script>
</body>
</html>
