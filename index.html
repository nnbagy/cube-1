<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <title>Particles – Limited Zoom</title>
  <style>
    body { 
      margin: 0; 
      padding: 0;
      overflow: hidden; 
      background: #000;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
      width: 100vw;
      height: 100vh;
      position: fixed;
    }
    canvas { 
      display: block; 
      width: 100%;
      height: 100%;
    }
    #zoomInfo {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: white;
      font-family: Arial, sans-serif;
      font-size: 12px;
      opacity: 0.7;
      pointer-events: none;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 10px;
    }
  </style>
</head>
<body>
<div id="zoomInfo">Standard size</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>

let scene, camera, renderer, sphere, uniforms;
let mouse = new THREE.Vector3();
let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
let particleCount, pointSize;

// Zoom variables - FIXED STANDARD SIZE
let cameraDistance = 3.0;
const STANDARD_SIZE = 3.0;  // Fixed standard size (can't go below this)
const MAX_ZOOM_IN = 1.5;    // Can zoom IN to 1.5 (larger cube)
const MAX_ZOOM_OUT = 4.0;   // Can zoom OUT to 4.0 (smaller cube)

let initialPinchDistance = 0;
let isPinching = false;
let zoomInfo;

init();
animate();

function init() {
    scene = new THREE.Scene();

    // Adjust camera for mobile aspect ratios
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 1000);
    camera.position.z = cameraDistance;

    renderer = new THREE.WebGLRenderer({ 
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
    });
    
    // Set proper size for device
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
    document.body.appendChild(renderer.domElement);

    zoomInfo = document.getElementById('zoomInfo');

    // Adjust particle count and size for mobile
    particleCount = isMobile ? 15000 : 50000;
    pointSize = isMobile ? 2.5 : 1.0;

    const positions = new Float32Array(particleCount * 3);

    // Create particles in a PERFECT CUBE shape
    const cubeSize = 2.0; // Fixed cube size for perfect shape
    
    for (let i = 0; i < particleCount; i++) {
        // Perfect cube coordinates - all axes same size
        positions[i*3] = (Math.random() - 0.5) * cubeSize;     // X
        positions[i*3+1] = (Math.random() - 0.5) * cubeSize;   // Y  
        positions[i*3+2] = (Math.random() - 0.5) * cubeSize;   // Z
    }

    const particleGeometry = new THREE.BufferGeometry();
    particleGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));

    uniforms = {
        uTime: { value: 0.0 },
        uMouse: { value: new THREE.Vector3(0,0,0) },
        uPointSize: { value: pointSize }
    };

    const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
            uniform vec3 uMouse;
            uniform float uPointSize;
            
            void main() {
                vec3 pos = position;

                float dist = distance(pos, uMouse);
                if (dist > 0.01) { // Avoid division by zero
                    pos += normalize(pos - uMouse) * (0.15 / dist);
                }

                gl_PointSize = uPointSize;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
        `,
        fragmentShader: `
            void main() {
                // Circular particles with smooth edges
                float d = distance(gl_PointCoord, vec2(0.5));
                if (d > 0.5) discard;
                
                // Smooth alpha for better looking particles
                float alpha = 1.0 - smoothstep(0.3, 0.5, d);
                gl_FragColor = vec4(0.2, 0.6, 1.0, alpha);
            }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    sphere = new THREE.Points(particleGeometry, material);
    scene.add(sphere);

    // Handle both mouse and touch events
    function updatePointerPosition(x, y) {
        // Convert to normalized device coordinates (-1 to +1)
        const normalizedX = (x / window.innerWidth) * 2 - 1;
        const normalizedY = -(y / window.innerHeight) * 2 + 1;
        
        // Map to cube coordinates (-1 to +1 cube space)
        mouse.set(normalizedX, normalizedY, 0.3);
        uniforms.uMouse.value.copy(mouse);
    }

    // Mouse wheel zoom for desktop - WITH LIMITS
    window.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoomSpeed = 0.001;
        let newDistance = cameraDistance + e.deltaY * zoomSpeed;
        
        // Apply limits
        if (e.deltaY < 0) {
            // Zoom IN (make larger) - allowed to MAX_ZOOM_IN
            newDistance = Math.max(MAX_ZOOM_IN, Math.min(STANDARD_SIZE, newDistance));
        } else {
            // Zoom OUT (make smaller) - limited, can't go too small
            newDistance = Math.max(STANDARD_SIZE, Math.min(MAX_ZOOM_OUT, newDistance));
        }
        
        cameraDistance = newDistance;
        camera.position.z = cameraDistance;
        updateZoomInfo();
    }, { passive: false });

    // Touch events for mobile
    let touches = [];
    
    function handleTouchStart(e) {
        e.preventDefault();
        touches = Array.from(e.touches);
        
        if (touches.length === 2) {
            // Start pinch zoom
            isPinching = true;
            initialPinchDistance = getPinchDistance(touches[0], touches[1]);
            zoomInfo.textContent = "Pinching...";
        } else if (touches.length === 1) {
            // Single touch for particle interaction
            updatePointerPosition(touches[0].clientX, touches[0].clientY);
        }
    }
    
    function handleTouchMove(e) {
        e.preventDefault();
        touches = Array.from(e.touches);
        
        if (touches.length === 2 && isPinching) {
            // Pinch zoom in progress
            const currentDistance = getPinchDistance(touches[0], touches[1]);
            const pinchChange = currentDistance - initialPinchDistance;
            
            // Calculate zoom based on pinch direction
            let newDistance = cameraDistance;
            
            if (pinchChange > 0) {
                // Fingers moving apart = ZOOM OUT (make smaller)
                // BUT LIMITED - can't go below STANDARD_SIZE
                newDistance = cameraDistance + (pinchChange * 0.01);
                newDistance = Math.max(STANDARD_SIZE, Math.min(MAX_ZOOM_OUT, newDistance));
            } else if (pinchChange < 0) {
                // Fingers moving together = ZOOM IN (make larger)
                // Allowed to go closer
                newDistance = cameraDistance + (pinchChange * 0.01);
                newDistance = Math.max(MAX_ZOOM_IN, Math.min(STANDARD_SIZE, newDistance));
            }
            
            cameraDistance = newDistance;
            camera.position.z = cameraDistance;
            initialPinchDistance = currentDistance;
            updateZoomInfo();
        } else if (touches.length === 1) {
            // Single touch for particle interaction
            updatePointerPosition(touches[0].clientX, touches[0].clientY);
        }
    }
    
    function handleTouchEnd(e) {
        e.preventDefault();
        touches = Array.from(e.touches);
        
        if (touches.length < 2) {
            isPinching = false;
            updateZoomInfo();
        }
    }
    
    function getPinchDistance(touch1, touch2) {
        const dx = touch1.clientX - touch2.clientX;
        const dy = touch1.clientY - touch2.clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }
    
    // Add touch event listeners
    window.addEventListener("touchstart", handleTouchStart, { passive: false });
    window.addEventListener("touchmove", handleTouchMove, { passive: false });
    window.addEventListener("touchend", handleTouchEnd, { passive: false });
    window.addEventListener("touchcancel", handleTouchEnd, { passive: false });

    // Mouse move for desktop
    window.addEventListener("mousemove", (e) => {
        updatePointerPosition(e.clientX, e.clientY);
    });

    // Reset to standard size with double tap
    window.addEventListener("dblclick", () => {
        cameraDistance = STANDARD_SIZE;
        camera.position.z = cameraDistance;
        updateZoomInfo();
    });
    
    // Double tap on mobile
    let lastTap = 0;
    window.addEventListener("touchend", (e) => {
        if (e.touches.length === 0) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            
            if (tapLength < 300 && tapLength > 0) {
                // Double tap detected
                cameraDistance = STANDARD_SIZE;
                camera.position.z = cameraDistance;
                updateZoomInfo();
            }
            lastTap = currentTime;
        }
    });

    // Handle window resize
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', function() {
        setTimeout(onWindowResize, 100);
    });
}

function updateZoomInfo() {
    if (Math.abs(cameraDistance - STANDARD_SIZE) < 0.05) {
        zoomInfo.textContent = "Standard size ✓";
    } else if (cameraDistance < STANDARD_SIZE) {
        const zoomPercent = Math.round(((STANDARD_SIZE - cameraDistance) / (STANDARD_SIZE - MAX_ZOOM_IN)) * 100);
        zoomInfo.textContent = `Zoom in: ${zoomPercent}%`;
    } else {
        const zoomPercent = Math.round(((cameraDistance - STANDARD_SIZE) / (MAX_ZOOM_OUT - STANDARD_SIZE)) * 100);
        zoomInfo.textContent = `Zoom out: ${zoomPercent}%`;
    }
}

function onWindowResize() {
    // Update camera aspect ratio
    const aspectRatio = window.innerWidth / window.innerHeight;
    camera.aspect = aspectRatio;
    camera.updateProjectionMatrix();
    
    // Update renderer size
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 2 : 3));
}

function animate() {
    requestAnimationFrame(animate);
    
    uniforms.uTime.value += 0.01;
    sphere.rotation.y += 0.002;
    
    renderer.render(scene, camera);
}

</script>
</body>
</html>
