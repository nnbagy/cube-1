<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cube Particles</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>

let scene, camera, renderer, particles, uniforms, mouse = new THREE.Vector3(0, 0, 0);
let cubeSize = 2.0; // Kubun ölçüsü

init();
animate();

function init() {
    scene = new THREE.Scene();
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 4;
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const particleCount = 20000;
    const positions = new Float32Array(particleCount * 3);
    
    // Hissəcikləri kubun içərisində yerləşdir
    for (let i = 0; i < particleCount * 3; i += 3) {
        positions[i] = (Math.random() - 0.5) * cubeSize;     // X: -1 ilə 1 arası
        positions[i + 1] = (Math.random() - 0.5) * cubeSize; // Y: -1 ilə 1 arası
        positions[i + 2] = (Math.random() - 0.5) * cubeSize; // Z: -1 ilə 1 arası
    }
    
    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    
    uniforms = {
        uTime: { value: 0.0 },
        uMouse: { value: new THREE.Vector3(0, 0, 0) },
        uCubeSize: { value: cubeSize }
    };
    
    const material = new THREE.ShaderMaterial({
        uniforms,
        vertexShader: `
            uniform float uTime;
            uniform vec3 uMouse;
            uniform float uCubeSize;
            
            varying vec3 vPosition;
            
            void main() {
                vPosition = position;
                
                // Əsas mövqe
                vec3 pos = position;
                
                // Kursor interaktivliyi
                float dist = distance(pos, uMouse);
                if (dist < 0.5) {
                    // Kursor yaxınlığında hissəcikləri itələ
                    vec3 pushDir = normalize(pos - uMouse);
                    float force = 0.3 * (0.5 - dist);
                    pos += pushDir * force;
                }
                
                // Kubun sərhədlərini yoxla
                pos.x = clamp(pos.x, -uCubeSize/2.0, uCubeSize/2.0);
                pos.y = clamp(pos.y, -uCubeSize/2.0, uCubeSize/2.0);
                pos.z = clamp(pos.z, -uCubeSize/2.0, uCubeSize/2.0);
                
                gl_PointSize = 2.0;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
            
            float clamp(float value, float minVal, float maxVal) {
                return max(min(value, maxVal), minVal);
            }
        `,
        fragmentShader: `
            varying vec3 vPosition;
            
            void main() {
                // Dairəvi nöqtə
                float d = distance(gl_PointCoord, vec2(0.5));
                if (d > 0.5) discard;
                
                // Rəngi mövqeyə görə dəyiş
                float r = 0.2 + 0.8 * (vPosition.x + 1.0) / 2.0;
                float g = 0.4 + 0.6 * (vPosition.y + 1.0) / 2.0;
                float b = 0.8 + 0.2 * (vPosition.z + 1.0) / 2.0;
                
                gl_FragColor = vec4(r, g, b, 1.0);
            }
        `,
        transparent: true,
        depthWrite: false
    });
    
    particles = new THREE.Points(geometry, material);
    scene.add(particles);
    
    // Kursorun 3D mövqeyini hesabla
    const raycaster = new THREE.Raycaster();
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
    
    window.addEventListener('mousemove', (event) => {
        // Ekran koordinatlarını -1 ilə 1 arasına çevir
        const x = (event.clientX / window.innerWidth) * 2 - 1;
        const y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // Raycaster ilə 3D mövqe tap
        raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
        const intersection = raycaster.intersectObject(particles);
        
        if (intersection.length > 0) {
            mouse.copy(intersection[0].point);
        } else {
            // Əgər heç bir hissəciyə dəymirsə, müstəvidə kəsişmə tap
            raycaster.ray.intersectPlane(plane, mouse);
        }
        
        uniforms.uMouse.value.copy(mouse);
    });
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
}

function animate() {
    uniforms.uTime.value += 0.01;
    
    // Yavaş fırlanma
    particles.rotation.x = Math.sin(uniforms.uTime.value * 0.1) * 0.1;
    particles.rotation.y += 0.002;
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}

</script>
</body>
</html>
